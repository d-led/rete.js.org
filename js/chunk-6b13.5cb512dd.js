(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-6b13"],{2494:function(e,n,o){e.exports=o.p+"img/processStartNode.0ec4463c.png"},"9d1a":function(e,n,o){"use strict";o.r(n);var t=function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("div",{staticClass:"engine"},[o("h1",[e._v("Движок")]),o("p",[e._v("Этот класс позволяет обрабатывать данные на основе потоков в узлах и передавать их из выходных данных во входные. Движок не зависит от других компонентов редактора. Все, что ему нужно - это идентификатор, воркеры Компонентов и JSON данные")]),o("Code",{attrs:{source:"engineNode"}}),o("p",[e._v("Он может работать независимо от Редактора")]),o("h2",[e._v("Обработка")]),o("p",[e._v("Обход узлов выполняется следующим образом:")]),o("img",{attrs:{src:e.processImg}}),o("p",[e._v("Рассмотрим ситуацию, когда во время работы в редакторе нужно сразу получать результаты изменений (это легко сделать с событием 'process')")]),o("Code",{attrs:{source:"engineProcess"}}),o("p",[e._v(" В общем случае при каждом изиенении в схеме (узлы, соединения, данные узла) необходимо выполнять обработку. \nВ связи с тем, что воркеры могут быть асинхронными, метод 'process' также является асинхронным.\nТак как действия, провоцирующие обработку, могут выполняться не дожидаясь завершения предыдущей обработки, нам необходим метод `abort`, который ожидает завершения предыдущей обработки и гарантирует целостность данных.")]),o("p",[e._v("Обычно есть какой-то основной узел, с которого должна начинаться обработка или все данные идут к нему, тогда вы можете указать его:")]),o("Code",[e._v("engine.process(data, node.id);")]),o("p",[e._v(" Это может быть важно в ситуациях, когда узел запрашивает данные одновременно из нескольких узлов.\nНапример, если стартовым узлом будет Output material, тогда верхняя и нижняя цепочка узлов будут обработаны параллельно.\nЕсли начать обработку с узла Lightness, тогда обработка нижних узлов будет начата только после получения результата в текущем.")]),o("img",{attrs:{src:e.startNodeImg}}),o("p",[e._v("Также вы можете передавать дополнительные аргументы внутрь воркеров")]),o("Code",[e._v("engine.process(data, null, arg1, arg2);")]),o("p",[e._v("Каждому воркеру, обработанному этим процессом, будут переданы аргументы")]),o("Code",{attrs:{source:"worker"}}),o("p",[e._v("Если во время обработки возникает ошибка (обнаружена рекурсия, неправильный startId, неверные данные), вы можете получить его сообщение и данные")]),o("Code",[e._v("engine.on('error', ({ message, data }) => { });")]),o("h2",[e._v("Кроссплатформенный Движок")]),o("p",[e._v("Внимание! Текущая версия движка на С++ не совместима с версией 1.0.0, но может быть обновлена при необходимости")]),e._m(0)],1)},s=[function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("ul",[o("li",[o("a",{attrs:{href:"https://github.com/retejs/cpp-engine"}},[e._v("Cpp Engine ")])])])}],r=o("c660"),i=o.n(r),c=o("2494"),p=o.n(c),a={data:function(){return{processImg:i.a,startNodeImg:p.a}}},d=a,u=o("2877"),g=function(e){e.options.code||(e.options.code={}),e.options.code["engineNode"]="var engine = new Rete.Engine('demo@0.1.0');\n\nengine.register(myComponent);\nawait engine.process(data);"},_=g,v=function(e){e.options.code||(e.options.code={}),e.options.code["engineProcess"]="editor.on('process', async () => {\n    await engine.abort();\n    await engine.process(editor.toJSON());\n});"},f=v,m=function(e){e.options.code||(e.options.code={}),e.options.code["worker"]="worker(node, inputs, outputs, arg1, arg2) {\n  outputs['num'] = node.data.num;\n}"},l=m,w=Object(u["a"])(d,t,s,!1,null,null,null);"function"===typeof _&&_(w),"function"===typeof f&&f(w),"function"===typeof l&&l(w),w.options.__file="index.vue";n["default"]=w.exports},c660:function(e,n,o){e.exports=o.p+"img/process.750edb1a.gif"}}]);
//# sourceMappingURL=chunk-6b13.5cb512dd.js.map